set cut_paste_input [stack 0]
version 13.2 v1
push $cut_paste_input
ParticleBlinkScript {
 kernelSourceGroup 1
 kernelSource "inline float fract (float x) \{return x-floor(x);\}\ninline float random(float co) \{ return fract(sin(co*(91.3458f)) * 47453.5453f); \}\ninline float3 random4(float3 seed)\{\n  float scramble = random(seed.x + seed.y * seed.z);\n  float3 rand;\n  rand.x = random(seed.x + scramble + 0.14557f + 0.47917f * seed.z)*2-1;\n  rand.y = random(seed.y * 0.214447f + scramble * 47.241f * seed.x)*2-1;\n  rand.z = random(seed.z * scramble + 3.147855f + 0.2114f * seed.y)*2-1;\n  return normalize(rand);\n\}\n\nfloat4x4 quaternionToMatrix(float4 quaternion) \{\n    // Extract quaternion components\n    float x = quaternion.x;\n    float y = quaternion.y;\n    float z = quaternion.z;\n    float w = quaternion.w;\n\n    // Calculate terms to avoid redundant calculations\n    float xx = x * x;\n    float yy = y * y;\n    float zz = z * z;\n    float xy = x * y;\n    float xz = x * z;\n    float yz = y * z;\n    float wx = w * x;\n    float wy = w * y;\n    float wz = w * z;\n\n    // Construct the rotation matrix\n    float4x4 matrix = float4x4(\n        1.0f - 2.0f * (yy + zz), 2.0f * (xy - wz),       2.0f * (xz + wy),       0.0f,\n        2.0f * (xy + wz),       1.0f - 2.0f * (xx + zz), 2.0f * (yz - wx),       0.0f,\n        2.0f * (xz - wy),       2.0f * (yz + wx),       1.0f - 2.0f * (xx + yy), 0.0f,\n        0.0f,                   0.0f,                   0.0f,                   1.0f\n    );\n\n    return matrix;\n\}\n\nfloat4 matrixToQuaternion(float4x4 matrix) \{\n    // Extract the 3x3 rotation component from the 4x4 matrix\n    float3x3 rotationMatrix = float3x3(\n        matrix\[0]\[0], matrix\[0]\[1], matrix\[0]\[2],\n        matrix\[1]\[0], matrix\[1]\[1], matrix\[1]\[2],\n        matrix\[2]\[0], matrix\[2]\[1], matrix\[2]\[2]\n    );\n\n    // Compute the trace of the matrix\n    float trace = rotationMatrix\[0]\[0] + rotationMatrix\[1]\[1] + rotationMatrix\[2]\[2];\n    float4 quaternion;\n\n    // Compute the quaternion based on the matrix trace and dominant diagonal element\n    if (trace > 0.0f) \{\n        float s = sqrt(trace + 1.0f) * 2.0f; // s = 4 * qw\n        quaternion.w = 0.25f * s;\n        quaternion.x = (rotationMatrix\[2]\[1] - rotationMatrix\[1]\[2]) / s;\n        quaternion.y = (rotationMatrix\[0]\[2] - rotationMatrix\[2]\[0]) / s;\n        quaternion.z = (rotationMatrix\[1]\[0] - rotationMatrix\[0]\[1]) / s;\n    \} else if ((rotationMatrix\[0]\[0] > rotationMatrix\[1]\[1]) && (rotationMatrix\[0]\[0] > rotationMatrix\[2]\[2])) \{\n        float s = sqrt(1.0f + rotationMatrix\[0]\[0] - rotationMatrix\[1]\[1] - rotationMatrix\[2]\[2]) * 2.0f; // s = 4 * qx\n        quaternion.w = (rotationMatrix\[2]\[1] - rotationMatrix\[1]\[2]) / s;\n        quaternion.x = 0.25f * s;\n        quaternion.y = (rotationMatrix\[0]\[1] + rotationMatrix\[1]\[0]) / s;\n        quaternion.z = (rotationMatrix\[0]\[2] + rotationMatrix\[2]\[0]) / s;\n    \} else if (rotationMatrix\[1]\[1] > rotationMatrix\[2]\[2]) \{\n        float s = sqrt(1.0f + rotationMatrix\[1]\[1] - rotationMatrix\[0]\[0] - rotationMatrix\[2]\[2]) * 2.0f; // s = 4 * qy\n        quaternion.w = (rotationMatrix\[0]\[2] - rotationMatrix\[2]\[0]) / s;\n        quaternion.x = (rotationMatrix\[0]\[1] + rotationMatrix\[1]\[0]) / s;\n        quaternion.y = 0.25f * s;\n        quaternion.z = (rotationMatrix\[1]\[2] + rotationMatrix\[2]\[1]) / s;\n    \} else \{\n        float s = sqrt(1.0f + rotationMatrix\[2]\[2] - rotationMatrix\[0]\[0] - rotationMatrix\[1]\[1]) * 2.0f; // s = 4 * qz\n        quaternion.w = (rotationMatrix\[1]\[0] - rotationMatrix\[0]\[1]) / s;\n        quaternion.x = (rotationMatrix\[0]\[2] + rotationMatrix\[2]\[0]) / s;\n        quaternion.y = (rotationMatrix\[1]\[2] + rotationMatrix\[2]\[1]) / s;\n        quaternion.z = 0.25f * s;\n    \}\n\n    // Normalize the quaternion\n    float magnitude = sqrt(quaternion.x * quaternion.x + quaternion.y * quaternion.y + \n                           quaternion.z * quaternion.z + quaternion.w * quaternion.w);\n    quaternion.x /= magnitude;\n    quaternion.y /= magnitude;\n    quaternion.z /= magnitude;\n    quaternion.w /= magnitude;\n\n    return quaternion;\n\}\n\nfloat radians(float degrees) \{\n    return degrees * (3.14159265f / 180.0f);\n\}\n\n\nkernel randomrotation : ImageComputationKernel<ePixelWise>\n\{\n  // Declare the particle attributes as Images:\n\n  Image<eReadWrite> p_orientation;\n  Image<eReadWrite> p_id;\n  // Declare our parameter storage\n  param:\n\nfloat3 random_rot;\n\n\n  // Define the parameters to the outside world\n  void define() \{\n  defineParam(random_rot, \"amount\", float3(0.0f, 0.0f, 0.0f));\n\n  \}\n\n\n\n\n  // Process the particle attributes\n  void process() \{\nfloat id = float(p_id());\n\n    float4x4 rotMat;\n    rotMat = quaternionToMatrix(p_orientation());\n\n    rotMat.rotateX(radians(random(id) * random_rot.x));\n    rotMat.rotateY(radians(random(id+123.45) * random_rot.y));\n    rotMat.rotateZ(radians(random(id+678.91) * random_rot.z));\n\n\n float4 quat = matrixToQuaternion(rotMat);\n    \n\n//    float3 rand = randomv(p_id());\n\n   p_orientation() = quat;\n\n  \}\n\};\n\n"
 name random_rotation
 selected true
 xpos 4303
 ypos 2650
 addUserKnob {20 User}
 addUserKnob {6 orient_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {13 amount}
 amount {350 360 360}
}
